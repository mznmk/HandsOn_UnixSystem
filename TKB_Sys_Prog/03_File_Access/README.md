# Tsukuba System Program

筑波大学／情報科学類 システムプログラム (2021年) の学習メモです。  

http://www.coins.tsukuba.ac.jp/~syspro/2021/  
http://www.coins.tsukuba.ac.jp/~syspro/2021/2021-04-28/index.html  
https://vimeo.com/channels/1707084  


## 第3週 ファイルアクセス

### 1. ファイルアクセス（基本）

- ファイルアクセスをするには，システムコールを用いる方法と，ライブラリ関数を用いる方法がある．  

< ライブラリ関数を用いたファイルの入出力 >  

- ライブラリ関数を用いたファイルの入出力において，ファイルを開き，閉じるためには fopen, fclose を用いる．  
- ファイルの入出力で便利な fread, fwrite という関数も用意されている  
	```c
	FILE  *fopen(const char *path, const char *mode);
	int    fclose(FILE *stream);
	size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);
	size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);
	```

FILE 構造体  

- ファイルを開くために使用する fopen の戻り値の型は FILE * （FILE 構造体へのポインタ，通称，ファイルポインタ）である．  
- ライブラリ関数を用いたファイルアクセスにおいては，ファイルポインタがファイルの代理人のようなものになる．  
-  FILE 構造体は，これらの情報を持つ  
    - 読み書きしているファイル  
    - ファイルに対し許される操作（読み込み，書き込み，または両方）  
    - 現在ファイルのどの部分をアクセスしているのか  
    - エラーは起きていないか  

ファイルのコピー  

- fopen() fclose() を使ったプログラム例：読込元=src 書出先=dst で決め打ち  
	[filecopy-lib1.c](./filecopy-lib1.c)  

main 関数の引数  

- プログラムを起動する時の引数は，main 関数への引数として渡される．  
	```c
	int main(int argc, char *argv[])
	```
- 上記のプログラムを，コピーするファイル名をコマンド行の引数として渡せるように変えると，次のようなプログラムになる．  
	[filecopy-lib2.c](./filecopy-lib2.c)  
- argc, argv を解釈する際には，引数の数をチェックすることが大切である． 

< システムコールを用いたファイルの入出力 >  

- システムコールを用いたファイルの入出力において，ファイルを開き，閉じるためには open, close を用いる．  
- 読み書きのためのシステムコールには read, write を用いる．  
	```c
	int     open(const char *pathname, int flags);
	int     open(const char *pathname, int flags, mode_t mode);
	int     close(int fd);
	ssize_t read(int fd, void *buf, size_t count);
	ssize_t write(int fd, const void *buf, size_t count);
	```

ファイルディスクリプタ  

- open はオープンに成功すると0以上の整数を返す．その整数は，ファイルディスクリプタ（ファイル記述子）と呼ばれる．  
- システムコールを用いたファイルアクセスでは，open で得られたファイルディスクリプタを指定することにより，read, write を用いてファイルの読み書きを行うことができる．  
- ファイルアクセスが終了したら，ファイルディスクリプタを引数にして close を呼ぶと，ファイルをクローズできる．  
- 一時にオープンできるファイルの数（ファイルディスクリプタの最大値）は制限されている。（ulimit -n を実行すると値を確認できる）  
- ulimit コマンドにより最大 10240 まで使用可能にできる。  

標準入出力のファイルディスクリプタ  

- 標準入出力のためのファイルディスクリプタとして0, 1, 2が割り当てられている．  
- 0が標準入力，1が標準出力，2が標準エラー出力に対応する．  
- これら3つのファイルディスクリプタは，プログラムが実行される時に明示的にオープンしなくても，使える状態になっている．  

ファイルのコピー  

- fopen() fclose() を使ったプログラム例を、システムコールを open() close()を用いるように書き換えると…  
	[filecoy-syscall.c](./filecopy-syscall.c)  

ライブラリ関数とシステムコールの混在  

- ライブラリ関数とシステムコールを混ぜて同一のファイルをアクセスすることは，プログラミング上は可能ではあるが，結果がおかしくなる可能性があるので，避けるべきである．  
- ファイルディスクリプタとファイルポインタのどちらかからどちらかへどうしても変換したい時には，以下の関数を使用することができる．  
	```c
	int   fileno(FILE *stream);            /* FILE 構造体のファイルディスクリプタを返す */
	FILE *fdopen(int fildes, char *mode);  /* ファイルディスクリプタから FILE 構造体を作る */
	int   fflush(FILE *stream);            /* バッファリングされたデータをフラッシュ */
	```

### 2. ファイルアクセス（応用）

< ファイルのランダムアクセス >  

- 全てをメモリ上に読み込むことが難しい大きなデータを扱う場合、必要なデータのみを読み書きすることになる。その場合、途中を読み飛ばすランダムアクセスができると効率が良い。  
- ランダムアクセスをするためには、lseek fseek を用いる。  
	```c
	off_t lseek(int fildes, off_t offset, int whence);
	int   fseek(FILE *stream, long offset, int whence);
	```

< 自分でバッファを確保してのファイルコピー >  

- fread, fwrite はライブラリ関数として実装されており，バイト単位での入出力も効率良く行えるように，バッファリングしている．  
- fread, fwrite は内部でバッファリングをするが，それとは別に，fread, fwrite にデータを渡すためのバッファをプログラムの中で確保する必要がある．そのバッファを malloc で確保するプログラムの例  
	[filecopy-buf.c](./filecopy-buf.c)  

### 3. 構造体の入出力

- まとめて扱うと便利なデータは，C プログラムでは構造体を用いて表現する．  

< 構造体のサイズ >  

sizeof  

- 構造体のデータをファイルに保存し，読み出すために，まず知らなくてはならないことは構造体の大きさである．  
- この構造体の大きさを知るためには sizeof 演算子を用いる．  
- 構造体の大きさは，必ずしもメンバの大きさの単純な和にはなるとは限らないことに注意．  

データファイルのポータビリティ  

- 構造体のデータを書き込んで作成したファイルのデータを様々なコンピュータで共有しようとする時に注意しなければいけないのは，データがどのようにファイルに書かれているのかという点である．  
- サイズ：サイズは環境依存である．  
- バイトオーダ：int 型の数値が4バイトで表されているとする．int 型の数値を100番地に書き込むと，その数値の各バイトは100〜103の番地に書き込まれる．数値の中の一番小さい部分を表すバイトを100番地，一番大きい部分を表すバイトを103番地に書き込むプロセッサ（リトルエンディアン）と， 逆に一番大きい部分を表すバイトを100番地，一番小さい部分を表すバイトを103番地に書き込むプロセッサ（ビッグエンディアン）がある． 
- パディング： 構造体などの複数のデータを組み合わせるデータ構造を用いるプログラムのコンパイルでは，コンパイラが各要素データの間に不使用領域を挟むことがある．その一つの理由は，データ構造のサイズを4や8の倍数にすることである．  
- アラインメント： 計算対象である数値をメモリ上に格納する時，そのプロセッサにとって最も都合が良いように配置するコードをコンパイラが生成する．  

< 構造体の入出力と動的メモリ確保 >  

utmp データの読み込み  

- /var/run/utmp というファイルには，現在ログインしているユーザなどのログイン情報が記録されている．  
- utmp のデータを fread を利用して1エントリごとに読み込み，ログイン情報を表示するプログラム
	[utmp.c](./utmp.c)  
- utmp ファイルの各エントリの内容を保持するリストを作ることを考える．書き直したプログラム  
	[utmp-list1.c](./utmp-list1.c)  
	[utmp-list2.c](./utmp-list2.c)  

< ファイルのメモリマッピング >  

- ファイルの内容にアクセスする方法として、ファイルをアドレス空間にマップするメモリマッピングと呼ばれる方法がある。  
- ファイルの内容を配列のように扱うことができ、配列の添字やポインタを用いてファイルの読み書きをできるようになる。  
- メモリマッピングを行うためには、mmap システムコールを使用する。  
	```c
	void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);
	int   munmap(void *addr, size_t length);
	```
- munmap は、マップされた領域を解放する。  
- _PATH_UTMP をアクセスするプログラム utmp.c を，メモリマッピングを用いるように変更したプログラム  
	[utmp-mmap()](./utmp-mmap.c)  

### 4. ポインタ（3）

< バッファへのポインタ >  

- 自分でバッファを確保してファイルをコピーするプログラム filecopy-buf.c を malloc による動的メモリ確保が行われないように変更したプログラム  
	[filecopy-buf-bad.c](./filecopy-buf-bad.c)  
- `bufが有効なメモリ領域を指していない可能性が高いため、実行するとエラーになる可能性が高い。たとえエラーを出さずに実行できてしまったとしても、どこかの領域を破壊している可能性が高い。  
- このプログラムはバグを含んでいるがコンパイルできてしまう．単純に cc や gcc コマンドをオプション無しで使用してコンパイルすると、何の警告も出力されないことが多い。  
- cc に -Wall というオプションを付けてコンパイルすると、buf が初期化されずに使用されているという警告が出力される。できるだけオプションを指定するほうが良い。  

< データ領域の種類と性質 >  

- グローバル変数が使用する領域は、プログラムの実行の開始から終了まで有効である。  
- ローカル変数が使用する領域は、その変数が宣言された関数が呼び出されてから呼び出し元に戻るまで有効である。スタック上に確保される。  
- ヒープ領域はプログラム実行開始後、必要な時に確保され不要になったら解放される領域であり、確保から解放まで有効である。領域が実行時に確保されるため、確保された領域を指し示す方法はポインタしかない。  

### 5. バッファオーバーフロー

- バッファオーバーフローはプログラムの実行（プロセス）を乗っ取るため，悪意を持った攻撃者によって引き起こされる．  
- バッファオーバーフローにより，攻撃者はプロセスに任意のプログラムを送り込んで実行させたり，任意のデータを送り込んで読み込ませたりすることができてしまい，プロセスは乗っ取られてしまう．  
- このような攻撃方法をバッファオーバーフロー攻撃（buffer overflow attacks）やスタックスマッシング (stack smashing) と呼ぶ．  

