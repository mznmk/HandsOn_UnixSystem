# Tsukuba System Program

筑波大学／情報科学類 システムプログラム (2021年) の学習メモです。  

http://www.coins.tsukuba.ac.jp/~syspro/2021/  
http://www.coins.tsukuba.ac.jp/~syspro/2021/2021-05-07/index.html  
https://vimeo.com/channels/1707084  


## 第4週 プロセス、リダイレクション、パイプ

### 1. プロセスの概念と機能

< プログラムとプロセス >  

- 実行形式のプログラムには，CPU が実行できる機械語命令とそれにより処理されるデータの集合（実行形式，ロードモジュール）が格納されている．  
- 実行中のプログラムがプロセスである． プロセスに入っている実行に必要な情報には，プログラムに含まれている情報もあれば，プログラムに含まれていない情報もある．  

< プロセスの機能 >  

- プロセスの重要な機能として 資源割り当て 保護 がある．  

資源割り当て  
- プロセスは，プロセッサ時間，メモリ，ファイル，キーボードやディスプレイ，プリンタなどのデバイスといった，処理を行うにあたって必要となる計算資源の割り当て単位である．  
    
保護  
- プロセスは，割り当てられた資源が保護される単位でもある．あるプロセスは他のプロセスに割り当てられた資源に対し許可なくアクセスすることはできない．  

< プロセスのメモリマップ >  

- 領域の用途  
	|                        |       |
	|------------------------|-------|
	|テキスト領域            |プログラムの機械語命令が置かれる領域．<br>この領域は読み出し専用になっており，同じプログラムを実行しているプロセスの間で共有可能になっている．|
	|データ領域（初期値あり）|0以外の初期値を持つ大域変数や，static と指定された局所変数が置かれる領域．|
	|データ領域（初期値なし）|プログラムの BSS (Block Started by Symbol) と呼ばれる部分に対応する領域．<br>初期値を持たないまたは初期値が0の大域変数や，static と指定された局所変数が置かれる領域．<br>プロセス生成時に確保され，0に初期化される．|
	|ヒープ領域              |malloc 関数などにより，プロセスの実行中に確保されるデータ領域．|
	|共有ライブラリ          |共有ライブラリを配置するための領域．<br>ヒープとスタックの間にとられる．<br>テキスト領域と同じく読み出し専用で，他のプロセスと共有される．|
	|スタック領域            |static と指定されていない局所変数，関数引数，<br>関数呼び出し時の戻り番地などが置かれる領域．|
	|引数，環境変数          |プログラムに渡される引数と環境変数は，スタック領域の最上位部分に格納されている．|

	メモリアドレス確認サンプル  
	実行してそれぞれの領域とメモリアドレスの値を確認してイメージを掴む  
	[memorymap.c](./memorymap.c)

< プロセスの属性 >  

|||
|-|-|
|PID（プロセス ID）|それぞれのプロセスにつけられる，プロセスを識別するための番号．<br>Linuxでは 0〜32767 の範囲の整数．|
|PPID（親プロセス ID）|そのプロセスを生成したプロセス（親プロセス）のプロセスID．|
|PGID（プロセスグループ ID）|所属するプロセスグループの ID．<br>プロセスグループは，複数プロセスにまとめてシグナルを送る場合などに使用される．|
|UID（ユーザ ID）           |プロセスを実行したユーザの ID．<br>これとは別にアクセス権限を表す実効ユーザ ID もある．|
|GID（グループ ID）         |プロセスを実行したグループの ID．<br>これとは別にアクセス権限を表す実効グループ ID もある．|
|ファイルディスクリプタ     |オープンしたファイルの表．|
|umask                      |ファイル作成時のモードを決める時にマスク値として使用される値．|
|制御端末|シグナルを受け取る端末．|
|カレントディレクトリ|現在のディレクトリ．相対パス名を使う場合の出発点となる．<br>current working directory とも言う．|
|ルートディレクトリ|ルートディレクトリはプロセスごとに決めることができる．<br>通常，アクセスできるファイルを制限するために使用する．|
|実行ステート|実行中か，停止中か，ゾンビ状態か，などのプロセスの実行状態．|
|優先順位|プロセスの実行優先順位．|
|シグナル制御情報|シグナルに対応してどの処理が行われるかの情報．|
|利用可能資源量|プロセスの使える資源の上限．|
|実行統計情報|これまでの資源利用量の統計情報．|

< 環境変数 >  

- 環境変数はプロセスに文字列で渡され，その文字列の場所は外部変数 environ により指し示される．  
- 環境変数を構成する文字列群の構造は argv の構造と同じであり，文字列の配列である．  
- 外部変数 environ はその配列を指すポインタ（従って型は char **）である．  
- 環境変数を（便利に）操作するために以下のライブラリ関数  
	```c
	char *getenv(const char *name);                                   /* 環境変数の値の取得 */
	int   putenv(char *string);                                       /* 環境変数の追加または修正 */
	int   setenv(const char *name, const char *value, int overwrite); /* 環境変数の追加または修正 */
	void  unsetenv(const char *name);                                 /* 環境変数の削除 */
	```

< プロセスを操作するコマンド >  

- よく使用するコマンド  
	|                         |                            |
	|-------------------------|----------------------------|
	|シェル sh, bash, zsh, ...|コマンドの実行（プロセス生成，プログラム実行），<br>リダイレクション，パイプなど|
	|ps, pstree, top          |プロセスの観察              |
	|kill                     |プロセスの（強制）終了      |
	|nice                     |プロセスの実行優先順位の制御|
	|limit                    |プロセスの利用可能資源の制御|
	|gdb                      |デバッグツール              |

### 2. プロセスの操作： プロセス生成，プログラム実行，プロセス終了

< プロセスの生成とプログラムの実行 >  

- ユーザのプログラムはプロセスにより実行される。  
- 例えばシェルがプログラムを実行する時の処理を詳しく見てみると…  
    - シェルを実行するプロセスは，コマンドを実行するプロセスを生成する  
    - 生成されたプロセスは，指定されたコマンドを実行する  
    - シェルは，コマンドを実行するプロセスが終了するのを待つ  
    - コマンドが終了すると，シェルの実行が再開される  
- これらのステップにはそれぞれ以下のシステムコールが対応している．  
	```c
	pid_t fork(void);
	int   execve(const char *filename, char *const argv[], char *const envp[]);
	pid_t wait(int *status)
	void  exit(int status);
	```
- fork システムコールは，fork システムコールを呼んだプロセスの複製を生成する． fork システムコールを呼んだプロセスが親プロセスとなり，複製され新たに生成されたプロセスが子プロセスになる．
- execve システムコールは，execve システムコールを呼んだプロセスに，指定されたプログラムをロードして実行する．
- wait システムコールは，子プロセスの終了を待つ．
- exit システムコールは，呼び出したプロセスを終了させる．

プログラム例（fork）  

- fork() のプログラム例  
	[fork.c](./fork.c)  

プログラム例（execve）  

- execve() のプログラム例：ls 引数なし  
	[execve0.c](./execve0.c)
	[execve1.c](./execve1.c)
- execve() のプログラム例：ls 引数あり  
	[execve2.c](./execve2.c)

プログラム例（fork&execve）  

- fork() execve() のプログラム例 (上の fork() execve() を組み合わせたもの)   
	[fork_exec.c_](./fork_exec.c)
- fork() execve() のプログラム例 (意図的にエラーを起こしたもの)   
	[execve_fail.c](./execve_fail.c)
- 特定のプロセスの終了を待つには waitpid を使用する．  

その他のシステムコール  

- exit は現在はライブラリ関数となっており，_exit がシステムコールである．  
- 特定のプロセスの終了を待つには waitpid を使用する．  
	```c
	void  _exit(int status);
	pid_t waitpid(pid_t pid, int *status, int options);
	```

< プログラム実行のためのライブラリ関数 >  

```c
int execl(const char *path, const char *arg, ...);
int execlp(const char *file, const char *arg, ...);
int execle(const char *path, const char *arg , ..., char * const envp[]);
int execv(const char *path, char *const argv[]);
int execvp(const char *file, char *const argv[]);
```
- execl, execlp, execle ではコマンドライン引数の渡し方が execve とは異なる．これらのライブラリ関数には，コマンドライン引数のように文字列を並べて引数を渡す．  
- execlp, execvp は環境変数 PATH を使用してプログラムをサーチしてくれる． よって，それらの関数の第一引数に渡すプログラムは絶対パスで書かなくても良い．  

### 3. リダイレクション

概要  

- リダイレクションは標準入出力をファイルに切り替える機能である．  
- ファイルディスクリプタ0, 1, 2によってファイルの入出力を行うためには，ファイルディスクリプタの付け替えをしてくれるシステムコールである dup か dup2 を呼ぶ．  
	```c
	int dup(int oldfd);
	int dup2(int oldfd, int newfd);
	```
- dup は新しいファイルディスクリプタとして，その時点で使用されていない最小のファイルディスクリプタの値を使用し，dup2 は newfd として指定された値を使用するという点だけが異なる．  
- dup2() を使用したリダイレクションの処理は…  
    (1) ファイルをオープンし，（例えば）ファイルディスクリプタ3を得る．  
    (2) 標準入力（ファイルディスクリプタ0）をクローズする．  
    (3) dup2 により，ファイルディスクリプタ3の複製をファイルディスクリプタ0として作成する．  
    (4) ファイルディスクリプタ3をクローズすることにより，ファイルはファイルディスクリプタ0からのみアクセスできるようになる．   

プログラム例  

- 第1引数に指定されたファイルを標準入力として wc を実行するプログラム  
	[redirect.c](./redirect.c)  

### 4. パイプ

概要  

- シェルでコマンドを実行する場合，パイプ機能を用いることで，あるコマンドの出力を別のコマンドの入力とすることができる．  
- パイプはプロセス間でデータをやり取りするための通信路を表現するデータ構造であり，入口と出口をプロセスに提供する．  
- プロセスがパイプの入口から書いたデータを，別のプロセスが出口から読み出すことができる．   
- パイプを実現するのが，その名の通り pipe システムコールである． 
	```c
	int pipe(int fildes[2]);
	```
- pipe システムコールを呼ぶと，入力と出力それぞれの口（ファイルディスクリプタ）を持つパイプが1本作られる．  
- ファイルディスクリプタは，システムコールの引数に受け取った fildes 配列に格納され，fildes[0] がパイプの出口，fildes[1] がパイプの入口のファイルディスクリプタになる．  
- pipe() を使用したパイプの処理は…  
    (1) pipe システムコールを呼ぶと，入力と出力それぞれの口（ファイルディスクリプタ）を持つパイプが1本作られる．  
    (2) この状態で fork を呼ぶと，親プロセスと子プロセスがパイプ（入出力の口）を共有した状態になる．  
    (3) 一方のプロセスが入力を，もう一方が出力の口を閉じると，プロセスからプロセスへデータを送れる（プロセス間通信ができる）状態になる．  

プログラム例  

- パイプを作成した後 fork を実行し，子プロセスから親プロセスへ文字列を送るプログラム：dup() dup2() 不使用  
	[pipe.c](./pipe.c)  
- パイプを作成した後 fork を実行し，子プロセスから親プロセスへ文字列を送るプログラム：dup2() 使用  
	[pipe2.c](./pipe2.c)  
- パイプの不要な出入り口をクローズする必要があるのはなぜだろうか？ 最も大きな理由は，パイプの入口に対応するファイルディスクリプタが"すべて"クローズされるまで，そのパイプの出口には EOF が送られないからである．  
- fork と execve がなぜ分かれているか．プロセスの生成と実行を一度に行うシステムコールがあったとして，同様のプロセス間通信を実現しようとしたら，プログラムはうまく書けるだろうか？ fork と execve が分かれていることにより，パイプはより使いやすくなり，リダイレクションはより実現しやすくなっている．  

### 5. プロセス操作のための他のシステムコール，ライブラリ関数

< プロセスの強制終了 >  

- プロセスを終了するために通常使用される kill コマンドは，kill システムコールを呼ぶことで実現される．  
- kill システムコールは，指定されたプロセスにシグナルと呼ばれるイベントを送るためのものである．  
	```c
	int kill(pid_t pid, int sig);
	```

< メモリ領域の確保 >  

- 現在のヒープ領域だけではメモリ領域が足りなくなった時にヒープ領域を拡大するために，システムが暗黙に以下のシステムコールを呼び出すことがある．  
- 呼び出し後はヒープ領域が拡大され，新たなメモリ領域確保ができるようになる． 
	```c
	int brk(void *end_data_segment);
	void *sbrk(ptrdiff_t increment);
	```

< 簡単なプログラム実行 >  

- popen や system を呼び出すと子プロセスが生成され，その子プロセスがシェルを起動し，そのシェルが command の引数に与えられたコマンド行を実行する．  
	```c
	FILE *popen(const char *command, const char *mode);
	int pclose(FILE *stream);
	int system(const char *command);
	```

< その他のシステムコール >  

- プロセスの実行優先順位や利用可能資源の制御，デバッグ等を行うためのシステムコール  
	```c
	int nice(int incr);
	int getrlimit(int resource, struct rlimit *rlp);
	int getrusage(int who, struct rusage *r_usage);
	int setrlimit(int resource, const struct rlimit *rlp);
	int ptrace(int request, pid_t pid, caddr_t addr, int data);
	```

