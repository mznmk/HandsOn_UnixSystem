# Tsukuba System Program

筑波大学／情報科学類 システムプログラム (2021年) の学習メモです。  

http://www.coins.tsukuba.ac.jp/~syspro/2021/  
http://www.coins.tsukuba.ac.jp/~syspro/2021/2021-05-07/index.html  
https://vimeo.com/channels/1707084  


## 第4週 プロセス、リダイレクション、パイプ

### 1. プロセスの概念と機能

< プログラムとプロセス >  

- 実行形式のプログラムには，CPU が実行できる機械語命令とそれにより処理されるデータの集合（実行形式，ロードモジュール）が格納されている．  
- 実行中のプログラムがプロセスである． プロセスに入っている実行に必要な情報には，プログラムに含まれている情報もあれば，プログラムに含まれていない情報もある．  

< プロセスの機能 >  

- プロセスの重要な機能として 資源割り当て 保護 がある．  

資源割り当て  
- プロセスは，プロセッサ時間，メモリ，ファイル，キーボードやディスプレイ，プリンタなどのデバイスといった，処理を行うにあたって必要となる計算資源の割り当て単位である．  
    
保護  
- プロセスは，割り当てられた資源が保護される単位でもある．あるプロセスは他のプロセスに割り当てられた資源に対し許可なくアクセスすることはできない．  

< プロセスのメモリマップ >  

- 領域の用途  
	|                        |       |
	|:----------------------:|:-----:|
	|テキスト領域            |プログラムの機械語命令が置かれる領域．この領域は読み出し専用になっており，同じプログラムを実行しているプロセスの間で共有可能になっている．|
	|データ領域（初期値あり）|0以外の初期値を持つ大域変数や，static と指定された局所変数が置かれる領域．|
	|データ領域（初期値なし）|プログラムの BSS (Block Started by Symbol) と呼ばれる部分に対応する領域． 初期値を持たないまたは初期値が0の大域変数や，static と指定された局所変数が置かれる領域．プロセス生成時に確保され，0に初期化される．|
	|ヒープ領域              |malloc 関数などにより，プロセスの実行中に確保されるデータ領域．|
	|共有ライブラリ          |共有ライブラリを配置するための領域． ヒープとスタックの間にとられる． テキスト領域と同じく読み出し専用で，他のプロセスと共有される．|
	|スタック領域            |static と指定されていない局所変数，関数引数，関数呼び出し時の戻り番地などが置かれる領域．|
	|引数，環境変数          |プログラムに渡される引数と環境変数は，スタック領域の最上位部分に格納されている．|

	メモリアドレス確認サンプル  
	実行してそれぞれの領域とメモリアドレスの値を確認してイメージを掴む  
	[memorymap.c](./memorymap.c)

< プロセスの属性 >  

※ 多いのでテキスト参照  

< 環境変数 >  

- 環境変数はプロセスに文字列で渡され，その文字列の場所は外部変数 environ により指し示される．  
- 環境変数を構成する文字列群の構造は argv の構造と同じであり，文字列の配列である．  
- 外部変数 environ はその配列を指すポインタ（従って型は char **）である．  

< プロセスを操作するコマンド >  

- よく使用するコマンド  
	|                         |     |
	|:-----------------------:|:---:|
	|シェル sh, bash, zsh, ...|コマンドの実行（プロセス生成，プログラム実行），<br>リダイレクション，パイプなど|
	|ps, pstree, top          |プロセスの観察|
	|kill                     |プロセスの（強制）終了|
	|nice                     |プロセスの実行優先順位の制御|
	|limit                    |プロセスの利用可能資源の制御|
	|gdb                      |デバッグツール|

### 2. プロセスの操作： プロセス生成，プログラム実行，プロセス終了

< プロセスの生成とプログラムの実行 >  

- ユーザのプログラムはプロセスにより実行される。  
- 例えばシェルがプログラムを実行する時の処理を詳しく見てみると…  
    - シェルを実行するプロセスは，コマンドを実行するプロセスを生成する `fork()`  
    - 生成されたプロセスは，指定されたコマンドを実行する `exec()`  
    - シェルは，コマンドを実行するプロセスが終了するのを待つ `wait()`  
    - コマンドが終了すると，シェルの実行が再開される `exit()`  
- fork システムコールは，fork システムコールを呼んだプロセスの複製を生成する． fork システムコールを呼んだプロセスが親プロセスとなり，複製され新たに生成されたプロセスが子プロセスになる．
- execve システムコールは，execve システムコールを呼んだプロセスに，指定されたプログラムをロードして実行する．
- wait システムコールは，子プロセスの終了を待つ．
- exit システムコールは，呼び出したプロセスを終了させる．
- fork() のプログラム例  
	[fork()](./fork.c)  
- execve() のプログラム例：ls 引数なし  
	[execve()](./execve0.c)
	[execve()](./execve1.c)
- execve() のプログラム例：ls 引数あり  
	[execve()](./execve2.c)
- fork() execve() のプログラム例 (上の fork() execve() を組み合わせたもの)   
	[fork() execve()](./fork_exec.c)
- fork() execve() のプログラム例 (意図的にエラーを起こしたもの)   
	[fork() execve()](./execve_fail.c)
- 特定のプロセスの終了を待つには waitpid を使用する．  

< プログラム実行のためのライブラリ関数 >  

- execve() 以外にも exec()ファミリー にはいろいろある、という話。  
- 引数のとり方の違う、さまざまなものがある。  

### 3. リダイレクション

- リダイレクションは標準入出力をファイルに切り替える機能である．  
- ファイルディスクリプタ0, 1, 2によってファイルの入出力を行うためには，ファイルディスクリプタの付け替えをしてくれるシステムコールである dup か dup2 を呼ぶ．  
- dup は新しいファイルディスクリプタとして，その時点で使用されていない最小のファイルディスクリプタの値を使用し，dup2 は newfd として指定された値を使用するという点だけが異なる．  
- dup2() を使用したリダイレクションの処理は…  
    (1) ファイルをオープンし，（例えば）ファイルディスクリプタ3を得る．  
    (2) 標準入力（ファイルディスクリプタ0）をクローズする．  
    (3) dup2 により，ファイルディスクリプタ3の複製をファイルディスクリプタ0として作成する．  
    (4) ファイルディスクリプタ3をクローズすることにより，ファイルはファイルディスクリプタ0からのみアクセスできるようになる．   
- dup2() のプログラム例  
	[dup2()](./redirect.c)  

### 4. パイプ

- パイプはプロセス間でデータをやり取りするための通信路を表現するデータ構造であり，入口と出口をプロセスに提供する．  
- プロセスがパイプの入口から書いたデータを，別のプロセスが出口から読み出すことができる．   
- パイプをもう少し詳しく見ると下図のようになる． データの流れの方向は，入口から出口の単方向であり，入口に書いた順番で出口から読み出される．  
 - pipe システムコールを呼ぶと，入力と出力それぞれの口（ファイルディスクリプタ）を持つパイプが1本作られる．  
- ファイルディスクリプタは，システムコールの引数に受け取った fildes 配列に格納され，fildes[0] がパイプの出口，fildes[1] がパイプの入口のファイルディスクリプタになる．  
- pipe() を使用したパイプの処理は…  
    (1) pipe システムコールを呼ぶと，入力と出力それぞれの口（ファイルディスクリプタ）を持つパイプが1本作られる．  
    (2) この状態で fork を呼ぶと，親プロセスと子プロセスがパイプ（入出力の口）を共有した状態になる．  
    (3) 一方のプロセスが入力を，もう一方が出力の口を閉じると，プロセスからプロセスへデータを送れる（プロセス間通信ができる）状態になる．  
- pipe() のプログラム例：dup() dup2() 不使用  
	[pipe()](./pipe.c)  
- pipe() のプログラム例：dup2() 使用  
	[pipe()](./pipe2.c)  
- パイプの不要な出入り口をクローズする必要があるのはなぜだろうか？ 最も大きな理由は，パイプの入口に対応するファイルディスクリプタが"すべて"クローズされるまで，そのパイプの出口には EOF が送られないからである．  
- fork と execve がなぜ分かれているか．プロセスの生成と実行を一度に行うシステムコールがあったとして，同様のプロセス間通信を実現しようとしたら，プログラムはうまく書けるだろうか？ fork と execve が分かれていることにより，パイプはより使いやすくなり，リダイレクションはより実現しやすくなっている．  

### 5. プロセス操作のための他のシステムコール，ライブラリ関数

< プロセスの強制終了 >  

- プロセスを終了するために通常使用される kill コマンドは，kill システムコールを呼ぶことで実現される．  
- kill システムコールは，指定されたプロセスにシグナルと呼ばれるイベントを送るためのものである．  

< メモリ領域の確保 >  

- 現在のヒープ領域だけではメモリ領域が足りなくなった時にヒープ領域を拡大するために，システムが暗黙に以下のシステムコールを呼び出すことがある．  
- 呼び出し後はヒープ領域が拡大され，新たなメモリ領域確保ができるようになる．  

< 簡単なプログラム実行 >  

- popen や system を呼び出すと子プロセスが生成され，その子プロセスがシェルを起動し，そのシェルが command の引数に与えられたコマンド行を実行する．  

< その他のシステムコール >  

