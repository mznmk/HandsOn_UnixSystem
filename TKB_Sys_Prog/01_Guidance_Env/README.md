# Tsukuba System Program

筑波大学／情報科学類 システムプログラム (2021年) の学習メモです。  

http://www.coins.tsukuba.ac.jp/~syspro/2021/  
http://www.coins.tsukuba.ac.jp/~syspro/2021/2021-04-14/index.html  
https://vimeo.com/channels/1707084  


## 第1週 ガイダンス，実行環境，コンパイル，デバッグ

### 1. 講義「システムプログラム」の目的

オペレーティングシステム（OS: Operating System）とは  

- OS はハードウェアの違いを隠蔽し，ユーザがプログラムを実行するための使いやすい環境を提供する  
- OSが提供する主な抽象概念  
	|抽象概念              |ハードウェア機能        |
	|:--------------------:|:----------------------:|
	|プロセス              |プロセッサ，メモリ      |
	|ファイル，ディレクトリ|ストレージ              |
	|プロセス間通信        |コンピュータ間の通信    |
	|シグナル              |割り込み                |
	|アクセス制御          |コンピュータ共有時の保護|

API（Application Program Interface）を用いたプログラミング  

- OS の提供する抽象概念の集合が，ユーザから見た場合のコンピュータになる．  
- その抽象的なコンピュータを操作するためのインタフェースとして API（Application Program Interface）が提供されている．  
- API を用いることにより，抽象化されたコンピュータを操作することができるようになる．  
-  API は一般に "OS カーネルが提供するシステムコール" "システムコールを便利に使えるようするための，また多くのプログラムで利用できる部品としてのライブラリやマクロ" により提供される．  

講義・演習で使用するプログラミング言語  

- POSIX (Portable Operating System Interface for UNIX) API を利用してプログラムを作成する．  
- POSIX は C 言語により規定されており，特にシステムコールを直接呼び出す方法は，C 言語に対してのみ提供されている．  
- 特に断りのない限り，C 言語とする．  

### 2. ソフトウェアの構成と「システムプログラム」

< プログラムの種類 >  

- ライブラリやシステムコールを通してUNIXカーネルを直接的に利用する．  

< UNIX OS の構成要素 >  

シェル  

- シェルは，ユーザの視点からOSを見た場合，OSを操作するためにOSを取り囲んでいる殻という意味である  
- シェルは CLI（Command Line Interface）を通して，ユーザからのコマンドを受け付け，解釈，実行し，その結果を出力する機能を提供する． 

X ウィンドウシステムと GUI（Graphical User Interface）  

- X ウィンドウシステムは，ビットマップディスプレイ上にウィンドウを表示するための基本的な機能を提供するだけである．  
- ユーザがウィンドウを操作するための GUI は，GNOME や KDE といったプログラム群（デスクトップ環境とも呼ばれる）により提供される．  

コマンド，アプリケーション  

- コマンドとは，ユーザが（シェルを通して）コンピュータに与える命令である．  

サーバ，デーモン  

- UNIX では，バックグラウンドで動作し様々なサービスを提供する裏方で働くプログラムのことをデーモン（daemon）と呼んでいたが，最近ではサーバと呼ぶことも多い． 

システムコール，ライブラリ，ミドルウェア  

- UNIX でプログラミングをする場合，システムコール，ライブラリ，ミドルウェアを使用してプログラムを作成する．  
- システムコールは，OS カーネルの機能を直接呼び出すためのインタフェースである．  
- ライブラリとミドルウェアはプログラムの部品となる関数の集合である．  
- システムコールもライブラリも，C プログラムから呼び出す場合はどちらも関数呼び出しの形態で使用できるため，同じに見える．  
- UNIX のマニュアルでは，システムコールは2章，ライブラリは3章に分類されている． 

UNIX カーネル  

- UNIX カーネルは，プロセッサの特権モードというハードウェアの全てを制御することのできる動作モードで動作し，直接ハードウェアを制御するプログラムである． 
- UNIX カーネルは，大まかに言ってプロセス管理，ファイルシステム，メモリ管理，ネットワーク，プロセッサ依存部，デバイスドライバからなる．  

< プログラム，ライブラリ関数，システムコールの関係 >  

- ライブラリ関数とシステムコールには，いくつか大きな違いがある．  
- ライブラリ関数はそれを使用するプログラムの一部となるが，カーネルは完全に独立したプログラムとして存在する  
- プログラムからの入出力は結局はシステムコールを通して実現される  
- ライブラリだけで実現される機能もある  

### 3. プログラムの実行環境

< プログラムとプロセスの関係 >  

- プログラムは，CPUが実行できる機械語命令とそれにより処理されるデータの集合（実行形式，ロードモジュール）がファイルに格納されたものである． 
- プロセスには実行中の情報が入っている．実行が進めばデータは書き換えられたり，追加されたりする．プログラムには含まれていない，実行中の履歴を格納するためのデータ（スタック）も必要である． 

< プロセスの観察 >  

- UNIX にはプロセスを観察するためのコマンドがいくつか用意されている． ps コマンドはプロセスの状態を得るための最も標準的なコマンドであり，全ての UNIX で使用できる．  

### 4. プログラムの開発環境

< マニュアルの読み方 >  

- マニュアル(man)の章立て  
	1章	コマンド  
	2章	システムコール  
	3章	ライブラリ関数  
	4章	デバイスファイル  
	5章	ファイル形式  
	6章	ゲーム  
	7章	その他  
	8章	管理用コマンド  
- 各章の説明用に intro というエントリが用意されている．  
	`man 2 intro`  

< プログラム作成から実行までの流れ >  

- プログラムの作成では，エディタでプログラムを記述し，それをCコンパイラでコンパイルし，実行を繰り返すことになる．  

< インデンテーション >  

- 他の人も読みやすく見た目にも綺麗なプログラムを書くことを心がけると良い．

    - 書式に一貫性を持たせる（書式を整えることにすら気を遣わないプログラマは信頼されない）  
    - 1行をあまり長くしすぎることがないようにする． 例えば1行を90文字程度に抑える． 1行が長くなりすぎたら，文の途中であっても改行する．  
    - 入り組んだ構文を使った結果インデントが深くなりすぎないように，処理の順番を入れ換えたり，一部の処理を別の関数にしたりするなどの工夫をする．  

< コンパイルとリンク >  

コンパイル・実行・修正  

cc により起動されるプログラム  

- cc コマンド自体は実はコンパイルの処理をしない。コンパイルに必要な処理をしてくれるコマンドを呼び出すだけ。  
- cc に -v オプションを追加すると、cc により起動されるプログラムの様子がわかる。  

cc -E  

- cc に -E オプションを追加すると、コンパイルの前処理を実行するプログラム（プリプロセッサ）だけが起動され、結果は標準出力（stdout）に出される。  

リンク  

- cc に -c オプションを追加すると、アセンブラまでが実行され、機械語コードなどが入ったオブジェクトプログラムが作られる。
- オブジェクトプログラムを cc の引数に指定すると、cc はサフィックスから引数のファイルがオブジェクトプログラムであると判定し、リンカを起動する。

動的リンクと静的リンク  

- 動的リンクとはライブラリを実行時にリンクする方法である．  
- 静的リンクでは，リンク時に全てのライブラリをリンクした実行形式のファイルを作成する．  
- 動的リンクされた実行形式のファイルが使用するライブラリは ldd コマンドで知ることができる  

< make コマンド >  

-  C プログラムを複数ファイルに分割した場合，まずそれぞれを cc -c によりオブジェクトプログラムにコンパイルする．そうすると，Cプログラムファイルごとに（拡張子が o の）オブジェクトプログラムのファイルができる．これらのオブジェクトプログラムのファイルをリンクして実行形式のファイルを作る．  
- コンパイル手順を自動化してくれるのが make コマンドである。  
- make コマンドは，カレントディレクトリにある makefile または Makefile を読み込み，そこに書かれているルールに従ってコンパイルを行う  
- make -n を実行すると、make はコマンドを実際に起動しないが、起動するはずだったコマンドを処理の流れとともに表示してくれる。  

< デバッガ >  

- ソースコードを参照しながらデバッガを用いたい場合は cc に -g オプションを付けてコンパイルする必要がある。ソースコードの何行目で問題が発生したのかがわかり、また大域変数、ローカル変数、関数などの名前を指定してその値やアドレスを調べることもできる。  

### 5. プログラミングとデバッグ

< プログラミング >  

- ある程度の大きさのプログラムをいきなり作成するのは難しい。  
- 問題や設定、条件を単純化し、それを解く小さい簡単なプログラムを作成し、ちゃんと動くようにするところから始める。  

< デバッグ >  

- 最も基本的なデバッグ方法は printf を用いる方法である。  
- printf を用いることで、制御の流れの確認・変数の値の確認 をすることができる。  

### 6. ポインタ（1）

< & と * の関係 >  

- アドレス演算子 & を変数の前に付けると，その変数の値を格納するために割り当てられた領域のアドレスが得られる．このアドレスのことをポインタ値という．  
- 間接参照演算子 * は，ポインタ値が指す領域に格納されている値を取り出す．領域に付けられた名前（変数名）ではなく，ポインタ値を用いて参照するので間接参照という．  

< ポインタを使うとできること >  

- ポインタ値はある変数（領域）を参照する値である．値であるので，別の関数にポインタ値を渡すことができる．渡された方の関数は，ポインタ値により参照される変数の値を変更することができる．  

< ポインタを使う時に気をつけること >  

初期化  

- ポインタ変数に適切な値（ポインタ値）を入れずに参照してはいけない。  
- 間違ったアドレスにデータを書き込む、または、書き込もうとすると問題が発生する。  
- 書き込めるデータ領域の中にあるが意図とは違う間違ったアドレスに書き込むと、書き込み自体は成功してしまい、プログラムの実行が進んでから問題が起こる。  

関数間でのポインタ値の受け渡し  

- 関数間でポインタ値を受け渡しをする時には。ポインタ値が参照する変数がどこで宣言（領域確保）されているのか、注意する必要がある。  
-  大域変数やヒープ領域（malloc して確保した領域）は、プログラム中どこでも有効であるので問題はない。  
- ローカル変数は、それを宣言した関数から return する前までの間だけ有効である。そのため、ローカル変数へのポインタ値を戻り値にしてはいけない。  

他のよくある間違い  

- ポインタ型変数を複数宣言するときには，それぞれの変数名の前に * を付ける．   

