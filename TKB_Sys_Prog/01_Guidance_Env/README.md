# Tsukuba System Program

筑波大学／情報科学類 システムプログラム (2021年) の学習メモです。  

http://www.coins.tsukuba.ac.jp/~syspro/2021/  
http://www.coins.tsukuba.ac.jp/~syspro/2021/2021-04-14/index.html  
https://vimeo.com/channels/1707084  


## 第1週 ガイダンス，実行環境，コンパイル，デバッグ

### 1. 講義「システムプログラム」の目的

※ 特にメモすることなし。  

### 2. ソフトウェアの構成と「システムプログラム」

※ 特にメモすることなし。  

< プログラムの種類 >  

< UNIX OS の構成要素 >  

< プログラム，ライブラリ関数，システムコールの関係 >  

### 3. プログラムの実行環境

※ 特にメモすることなし。  

< プログラムとプロセスの関係 >  

< プロセスの観察 >  

### 4. プログラムの開発環境

< マニュアルの読み方 >  

- マニュアル(man)の章立て  
	1章	コマンド  
	2章	システムコール  
	3章	ライブラリ関数  
	4章	デバイスファイル  
	5章	ファイル形式  
	6章	ゲーム  
	7章	その他  
	8章	管理用コマンド  
- 各章の説明用に intro というエントリが用意されている．  
	`man 2 intro`  

< プログラム作成から実行までの流れ >  

< インデンテーション >  

< コンパイルとリンク >  

- cc コマンド自体は実はコンパイルの処理をしない。コンパイルに必要な処理をしてくれるコマンドを呼び出すだけ。  
- cc に -v オプションを追加すると、cc により起動されるプログラムの様子がわかる。  
- cc に -E オプションを追加すると、コンパイルの前処理を実行するプログラム（プリプロセッサ）だけが起動され、結果は標準出力（stdout）に出される。
- cc に -c オプションを追加すると、アセンブラまでが実行され、機械語コードなどが入ったオブジェクトプログラムが作られる。
- オブジェクトプログラムを cc の引数に指定すると、cc はサフィックスから引数のファイルがオブジェクトプログラムであると判定し、リンカを起動する。

< make コマンド >  

- コンパイル手順を自動化してくれるのが make コマンドである。  
- make -n を実行すると、make はコマンドを実際に起動しないが、起動するはずだったコマンドを処理の流れとともに表示してくれる。  

< デバッガ >  

- ソースコードを参照しながらデバッガを用いたい場合は cc に -g オプションを付けてコンパイルする必要がある。ソースコードの何行目で問題が発生したのかがわかり、また大域変数、ローカル変数、関数などの名前を指定してその値やアドレスを調べることもできる。  

### 5. プログラミングとデバッグ

< プログラミング >  

- ある程度の大きさのプログラムをいきなり作成するのは難しい。  
- 問題や設定、条件を単純化し、それを解く小さい簡単なプログラムを作成し、ちゃんと動くようにするところから始める。  

< デバッグ >  

- 最も基本的なデバッグ方法は printf を用いる方法である。  
- printf を用いることで、制御の流れの確認・変数の値の確認 をすることができる。  

### 6. ポインタ（1）

< & と * の関係 >  

- アドレス演算子 & を変数の前に付けると，その変数の値を格納するために割り当てられた領域のアドレスが得られる．このアドレスのことをポインタ値という．  
- 間接参照演算子 * は，ポインタ値が指す領域に格納されている値を取り出す．領域に付けられた名前（変数名）ではなく，ポインタ値を用いて参照するので間接参照という．  

< ポインタを使うとできること >  

- ポインタ値はある変数（領域）を参照する値である．値であるので，別の関数にポインタ値を渡すことができる．渡された方の関数は，ポインタ値により参照される変数の値を変更することができる．  

< ポインタを使う時に気をつけること >  

初期化  

- ポインタ変数に適切な値（ポインタ値）を入れずに参照してはいけない。  
- 間違ったアドレスにデータを書き込む、または、書き込もうとすると問題が発生する。  
- 書き込めるデータ領域の中にあるが意図とは違う間違ったアドレスに書き込むと、書き込み自体は成功してしまい、プログラムの実行が進んでから問題が起こる。  

関数間でのポインタ値の受け渡し  

- 関数間でポインタ値を受け渡しをする時には。ポインタ値が参照する変数がどこで宣言（領域確保）されているのか、注意する必要がある。  
-  大域変数やヒープ領域（malloc して確保した領域）は、プログラム中どこでも有効であるので問題はない。  
- ローカル変数は、それを宣言した関数から return する前までの間だけ有効である。そのため、ローカル変数へのポインタ値を戻り値にしてはいけない。  

