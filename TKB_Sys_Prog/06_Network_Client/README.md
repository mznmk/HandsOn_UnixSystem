# Tsukuba System Program

筑波大学／情報科学類 システムプログラム (2021年) の学習メモです。  

http://www.coins.tsukuba.ac.jp/~syspro/2021/  
http://www.coins.tsukuba.ac.jp/~syspro/2021/2021-05-26/index.html  
https://vimeo.com/channels/1707084  


## 第6週 ネットワーク・プログラミング／クライアント側

### 1. TCP/IPの基本的な考え方

https://vimeo.com/551456027?embedded=false&source=video_title&owner=110451643  

- インターネット上のアプリケーションの多くは、TCP/IPという仕組みを用いて 通信を行っている。  

< ストリーム >  

- TCP/IPは、信頼性のある（reliable）双方向のストリーム転送サービス （stream transport service）を提供する通信プロトコルである（図１）。  
- ストリームは、次のような性質がある転送サービスである。
    - データの送り手と受けての間に結合(connection，通信路)が作られる  
    - 複数回に分けて送り出したデータの順番が入れ替わることはないが、データの区切りは保存されない  
    - 送り出したデータが相手に届くようにがんばる（best effort。途中で失 われた時には、再送する）   

< 通信路の開設 >  

-  TCP/IP では、プロセスとプロセスが、電話で会話をするように通信が行われる。TCP/IPでは、電話を掛ける方をクライアント・プロセス、電話を待つ方をサーバ・プロセスという。  
- TCP/IP では、回線を接続する段階では、クライアント・ プロセスとサーバ・プロセスは非対称である。一度通信路が確立された後は、 両方のプロセスは、TCP/IPのレベルでは、まったく対称的になる。  
- TCP/IPにおいてプロセス間に通信路を開設するには、IPアドレスとポート番号が必要である。ポート番号は、同じIPアドレスを持つホスト（ネットワークに接続されたコンピュータ）上で動いているプロセスを区別するために使われる。   
- 通信路が開設される手順を示す。
    - サーバ・プロセスが、ポート番号を指定して、接続要求受付用ポートを作る。（注意：要求受付用ポートでは、データの送受信はできない。）  
    - サーバ・プロセスが、クライアント・プロセスからの接続要求を待つ。  
    - クライアント・プロセスが通信用ポートを作り、それを使ってサーバ・プロセスが動いているホストのＩＰアドレスと、サーバ・プロセスが作った接続要求受付用ポートのポート番号を使って、接続要求を行う。  
    - 接続要求が受け付けられると、サーバ側では、新たに通信用ポートが作られ、サーバ・プロセスから利用可能になる。これは、特定のクライアント との通信のために使われる。  
    - 以後、クライアント・プロセスとサーバ・プロセスは、データを送受信する。順番はどちらからが先でも良い。  
- TCP/IPにおける通信路開設において、クライアントは、サーバ側の接続要求受 付用ポートのポート番号を、事前に知っている必要がある。  

### 2. クライアント・サーバ・モデル

- クライアント・サーバ・モデルは、プロセス間通信を構造化したものであり、最近の用語でいうと、デザイン・パターンの１つである。    
- プロセス間通信を構造化するという意味でのクライアント・サーバ・モデルでは、まずプロセスをクライアントとサーバの２種類に分ける。   
- クライアントもサーバも、多くの場合、内部に１つループを持ち、次の動作を繰り返す。  
	- クライアント
		先に(要求)メッセージを送信し、後で(応答)メッセージを受信する。  
	- サーバ
		先に(要求)メッセージを受信し、後で(応答)メッセージを送信する。  
- クライアント・サーバ・モデルに基づくプログラムには次のようなことを行うプロセスは存在しない。
    送信しかやらない
    受信しかやらない
    送信を２回して受信を１回だけやる
    受信したら、処理の内容によって送信したりしなかったりする 

< クライアントのパタン >  

```c
com = tcp_connect();       // 接続要求。accept() と対応。

write(com, message);       // 要求メッセージの送信
read(com, message);        // 応答メッセージの受信
write(com, message);       // 要求メッセージの送信
read(com, message);        // 応答メッセージの受信
...                        // 必要回数繰り返す

close(com);                // 接続の切断。
```

< サーバのパタン >  

```c
acc = tcp_acc_port();          // 受付端の登録。
while( 1 )
{
	com = accept(acc);         // 実際の受付。connect() と対応。
	while( !eof(com) )
	{
		read(com, message);    // 要求メッセージの受信
		write(com, message);   // 応答メッセージの送信
	}
	close(com);                // 接続の切断。
}
```

< 情報科学類「システムプログラム」独自のクライアントを作成するためのAPI >  

- この講義では、次の独自のAPIを用いる。  
	```c
	int tcp_connect( char *server, int portno ) [独自]
		通信用ポートを作成し、 ホスト名 server のポート番号 (portno) へ TCPで通信路を開設する。 そのTCP/IPのストリームに対応したファイル記述子を返す。 
	int fdopen_sock( int sock, FILE **inp, FILE **outp ) [独自]
		tcp_connect() で得られた、TCP/IPのファイル記述子を、2つの FILE *に変換する。2つのうち、1つは受信用、もう1つは送信用。 
	```
- tcp_connect() と fdopen_sock() の働きにより、次の標準の関数を用いてネッ トワークのデータを送受信することができる。  
```c
int fprintf(FILE *out,char *fmt, ...) [標準]
    out に結びついた TCP/IP のストリームに対してメッセージを送信する。 
char *fgets(char *buf, int n, FILE *in ) [標準]
    in に結びついた TCP/IP のストリームに対からメッセージを 1行受信する。 
size_t fwrite(void *buf, size_t size, size_t nitems, FILE *out) [標準]
    out に結びついた TCP/IP のストリームに対してbuf 番地にある長さ size バイトの構造体を nitems 個送信する。構造体ではなく、バイト単位で送 信したい場合には、size には 1 を指定し、nitems には、バッファの大きさを 指定する。 
size_t fread(void *buf, size_t size, size_t nitems, FILE *in)) [標準]
    in に結びついた TCP/IP のストリームから size バイトの長さの構造体 を nitems だけ受信する。構造体ではなく、バイト単位で受信したい場合には、 size には 1 を指定し、nitems には、バッファの大きさを指定する。
```

### 3. TCP/IP の汎用クライアント・プログラムとしての telnet コマンド

https://vimeo.com/551456164?embedded=false&source=video_title&owner=110451643  

< telnet コマンドとは >  

- telnet コマンドは、本来は、遠隔ログインのコマンドであり、 通常次のように使われる。  
	```sh
	telnet hostname
	```

< TCPの汎用クライアントとしてのtelnet >  

- telnet コマンドに、次のようにポート番号(23のtelnetサービス以外)を与える ことで、文字列を送受信するようなプロトコルについては 汎用のTCPのクライアントとして使える。  
	```sh
	telnet hostname portno
	```

< telnetによるecho サーバへの接続 >  

- echo サーバは、送られて来た文字列（最後に改行）をそのまま送り返すサーバ である。  

< telnetによるdaytime サーバへの接続 >  

< echoサービスと daytimeサービス >  

< 様々なOSでのtelnetコマンド >  

### 4. echoサービスのクライアント

https://vimeo.com/551456408?embedded=false&source=video_title&owner=110451643  

< echo-client-fdopen-one.c >  

[echo-client-fdopen-one.c](./echo-client-fdopen-one.c)  
- このプログラムは、コマンドラインから３つの引数をとる。
- 第１引数で指定されたホスト上の、第２引数で指定されたポートで動作しているサーバに接 続する。そして、第３引数で与えられたメッセージをサーバへ送る。  
- echo サービスのサーバは、同じ文字列を送り返して来る。  
- このプログラムは、サーバから送り返されてきた文字列を受取り、結果を画面に表示する。  

echo-client-fdopen-one.c のmain()  

- main() 関数は、コマンドラインの引数を調べて、echo_client_one() を呼んでいる。  
- 第2引数のポート番号については、strtol() で、文字列として与えられた数を、int に変換している。   

echo_client_one()  

- echo_client_one() では、tcp_connect() という関数を呼び出している。この結果、 サーバとの間に TCP/IP通信路の開設され、通信可能なファイル記述子 (ファイルディスクリプタ) が返される。  
- このファイル記述子は、標準入出力(0,1,2)や open() システム・コールの結果と同じもので、 write() システムコールや read() システムコールの第一引数として使うことができる。  
- つまり、write() システムコールを使うと、ネットワークに対してデータを送り出すことができ、read() システムコールを使うとネットワークからデータを受け取ることができる。最後に不要になったら close() で解放する。  
- このプログラムでは、fdopen_sock() を使って、通信可能なファイル記述子 com から２つの FILE * を作成している。１つは、入力用、１つは出力用である。その結果、 高水準入出力ライブラリ を使って通信が行えるようになっている。  
- fprintf() で出力用の FILE * に書き込むと、ネットワークに対してデータが送り出される。入力用の FILE * に fgets() を行うと、ネットワークからデータを受け取ることができる。  
- echo_send_request() を呼び出して、要求メッセージを送信している。  
- echo_receive_reply() を呼び出して、応答メッセージを受信している。  

echo_send_request()  

- エコー・サービスで、要求メッセージを 送信する関数である。  

echo_receive_reply()  

- エコー・サービスで、応答メッセージを 受信する関数である。  
- echo サービスでは、１行送り、１行受け取る。  
- 他のサービスでは、１行送っ て複数行受け取ったり、受け取る方では行の概念がなくなるもの(HTTPで画像 データを受け取る場合など)もある。その場合は、fprintf() や fgets() では なくて、fwrite() や fread() を使う必要がある。  

### 5. HTTP

https://vimeo.com/551456502?embedded=false&source=video_title&owner=110451643  

- ブラウザは、Web サーバとの間に TCP/IP による 通信路を開設する。そして、クライアントは、必要なデータを得るための命令を送る。  
- これに対してサーバは、命令に応じた処理を行い結果を返す。この命令の形式や結果の形式を定めたものが、HTTP である。  
- HTTP 通信プロトコルを 受け付けるサーバを、HTTP サーバと呼ぶ。  

< HTTPの要求 >  

- HTTP の要求は、最初に要求の種類（メソッド）を含む行があり、以後、オプションが続く。最後に、空行があり、要求の終わりを示す。 たとえば、次のような URL を持つデータをアクセスすることを考える。`http://www.coins.tsukuba.ac.jp:80/~syspro/`  

- Firefox などのクライアントは、まずホスト名 www.coins.tsukuba.ac.jp を IP アドレスに変換する。そして、その I アドレスとポート 番号 80 を使ってサーバとの間に TCP/IP の通信路を開設する。  
- そして、クライアントは、開設した通信路を使って、サーバに次のような文字列を送る。  
	```
	GET /~syspro/ HTTP/1.0←↓
	Host: www.coins.tsukuba.ac.jp←↓
	←↓
	```
- ここで、"GET" が命令の種類、"/~syspro/" は、GETの引数の、要求しているデータを表わす URL (ファイル名)、"HTTP/1.0" は、使っているプロトコル のバージョンである。次の空行は、命令のヘッダ部分の終りを意味するものであり、必要である。「←」は、キャリッジ・リターンのコード(0x0d, C言語で '\r')、「↓」は、ラインフィード(ニューライン)のコード(0x0a, C言語で'\n')である。HTTP の ヘッダでは、行末に「←↓」を付けるように規定されている。（サーバを構築 する場合には、「←」か「↓」のどちらか１つしかこない場合でもきちんと動 作することが望ましい。）  

- "Host:" は、名前ベースの仮想ホストを使っている場合に必要となる。 

HTTPの要求での Host: の役割  

- 1つの httpd サーバで、複数のドメイン名の Web サーバを兼ねていることがある。この機能を、Apache httpd では、仮想ホスト( バーチャルホスト、virtual host)と呼んでいる。  

< HTTPの応答 >  

- GET による要求に対して、サーバは、クライアントへ次のような応答メッセー ジを送り返す。  
	```
	HTTP/1.1 200 OK←↓
	Date: Wed, 12 May 2021 09:48:44 GMT←↓
	Server: Apache←↓
	Last-Modified: Wed, 12 May 2021 09:47:44 GMT←↓
	ETag: "739-5c21ee7094cf8"←↓
	Accept-Ranges: bytes←↓
	Content-Length: 1849←↓
	Connection: close←↓
	Content-Type: text/html←↓
	←↓  (空行)
	本文（HTML）
	```
- 応答のうち、最初の行が、状態行（status line）と呼ばれる、要求が成功したか失敗したかわ表わしている行である。"200" とは、成功したという意味である。  
- ２行目から最初の空行（「←↓」だけの行）までは、応答メッセージのヘッダである。応答メッセージのヘッダには、データの型や、サーバ のバージョン、データが更新された日付と時刻、バイト数などが記録されている。  
- 応答で、最初の空行（「←↓」だけの行）の次が、データの本体である。この例では、HTMLで記述されたデータが返されている。  
- サーバは、データ転送が完 了すると、TCP/IP の通信路を切断する。  

< telnetによるWWWサーバへのアクセス >  

< HTTPのメソッド >  

よく使われるHTTP で定義されている命令  
```
命令		説明
--------------------------------------------------------------------
GET		情報を得る（ヘッダと本体の両方）
HEAD		情報のヘッダのみを得る
POST		新しく情報を作る
```

< HTTPの応答 >  

HTTPの応答では、次のようなコードがよく使われる。  
```
状態コード	説明
--------------------------------------------------------------------
200		OK(エラーなし)
301		要求されたデータが移動した
302		見つからない
303		別のページを見よ
304		ページは変更されていない
400		要求の形式にエラーがある
401		ページの閲覧が承認されななかった
403		アクセスが許されていない
404		要求されたデータが見つからない
500		サーバで内部エラーが起きた
501		メソッドが実装されていない
```

### 6. 細かい話

TCP/IP  

- TCP と IP という2つのプロトコルか らなる。  
- TCP/IP 上の応用層と、IP データグラムを運ぶ物理層まで考えると、 全体としては 4 層のプロトコル・スタックからなる。  

ソケットAPI  

- Unix 系のオペレーティング・システム上でTCP/IPを使うプログラムを開発する には、ソケットAPIを用いる。  

DNS(Domain Name System)  

- DNS は、TCP/IP と共に使われる名前サービスである。  
- プログラムで利用するには、一般にはライブラリ関数 getaddrinfo() を使う。   

tcp_connect()の詳細  

- 通信路の開設の仕事のうち、クライアント側の仕事をする関数である。  

fdopen_sock()の詳細  

- fdopen_sock() は、TCP/IP による通信を、fprintf(), fgets(), fread() 等で 行えるようにする関数である。  

marshaling/unmarshaling  

- プログラム中のデータ項目とネットワーク上を流れるメッセージに対応づける。  

